_repr: $[tokens][
    ignorable: [:function :literal :pathLiteral]
    reprToken: $[token :any][
        if inline? token            ; :inline should be 
            -> return _repr token    ; recurively evaluated

        if contains? ignorable type token
            -> return as.code token

        switch throws? [value: var token]
            -> as.code token
            -> as.code value
    ]

    tokens | map => [reprToken &] 
           | join.with: " "
]

define :assertion [
    init: method [condition :block][
        \_message: _repr condition
        \_status: equal? @condition @[true]
    ]

    string: method [][
        ~"assertion: |\_message|"
    ]

    logical: method [][
        \_status
    ]
]

assert: $[condition :block][
    passBlock: -> print [color #yellow ~"|_unittTestsIndentation|✅ |template|"]
    failBlock: -> print [color #yellow ~"|_unittTestsIndentation|❌ |template|"]
    skipBlock: [ 
        print [color #yellow ~"|_unittTestsIndentation|⏩ |template|"]
        print ~"|_unittTestsIndentation|     skipped! \n"
    ]

    if skip? [
        do skipBlock
        return null
    ]

    assertion: to :assertion @[condition]

    (to :logical assertion)? 
        passBlock
        failBlock

    print ~"|_unittTestsIndentation|     |to :string assertion|\n"
]