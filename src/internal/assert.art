_repr: $[tokens][
    ignorable: [:function :literal :pathLiteral]
    reprToken: $[token :any][
        if inline? token            ; :inline should be 
            -> return _repr token   ; recurively evaluated

        if contains? ignorable type token
            -> return as.code token

        switch throws? [value: var token]
            -> as.code token
            -> as.code value
    ]

    tokens | map => [reprToken &] 
           | join.with: " "
]

define :assertion [
    init: method [condition :block][
        \_condition: condition
        \_status: equal? @condition @[true]
    ]

    string: method [][
        repr: switch attr 'static
            -> as.code \_condition  
            -> _repr \_condition

        ~"assertion: |repr|"
    ]

    logical: method [][
        \_status
    ]
]

assert: $[condition :block][

    ident: $[value]
        -> join @[_unittTestsIndentation if attr 'extra ["     "] value]
    format: $[status :string] 
        -> color #yellow ident ~"|status| |template|"

    if skip? [
        print format "⏩"
        print ident.extra ~"skipped!"
        print ""
        return null
    ]

    assertion: to :assertion @[condition]

    (to :logical assertion)? 
        -> print format "✅"
        -> print format "❌"

    print ident.extra to :string assertion
    print ""
]