_repr: $[tokens][
    ignorable: [:function :literal :pathLiteral]
    reprToken: $[token :any][
        if inline? token            ; :inline should be 
            -> return _repr token   ; recurively evaluated

        if contains? ignorable type token
            -> return as.code token

        switch throws? [value: var token]
            -> as.code token
            -> as.code value
    ]

    tokens | map => [reprToken &] 
           | join.with: " "
]

define :assertion [
    init: method [condition :block][
        \_message: _repr condition
        \_status: equal? @condition @[true]
    ]

    string: method [][
        ~"assertion: |\_message|"
    ]

    logical: method [][
        \_status
    ]
]

assert: $[condition :block][

    ident: $[value][
        join @[_unittTestsIndentation if attr 'extra ["     "] value]
    ]

    passBlock: -> print [color #yellow ident ~"✅ |template|"]
    failBlock: -> print [color #yellow ident ~"❌ |template|"]
    skipBlock: [ 
        print [color #yellow ident ~"⏩ |template|"]
        print ident.extra ~"skipped! \n"
    ]

    if skip? [
        do skipBlock
        return null
    ]

    assertion: to :assertion @[condition]

    (to :logical assertion)? 
        passBlock
        failBlock

    print ident.extra ~"|to :string assertion|\n"
]